// lib/recommend.ts

import { products, type Product, type Vibe, vibes } from "./data";
import type { StructuredProfile } from "./aiProfile";

export type RecommendRequest = {
  answers?: string[];
  selectedVibes?: string[];
  limit?: number;

  /**
   * Optional structured profile generated by Groq
   * from the user's free-text answers.
   */
  structuredProfile?: StructuredProfile;
};

export type ScoredProduct = {
  product: Product;
  score: number;
  matchedVibes: Vibe[];
  matchedKeywords: string[];
};

const DEFAULT_LIMIT = 5;

/**
 * Hybrid scoring:
 * - Boost if product belongs to a selected vibe
 * - Boost if quiz answers contain keywords found in product description or vibe tags
 * - Extra boost if AI-derived structured tags (mood, season, notes, etc.) match the product
 */
export function recommendProducts(payload: RecommendRequest): ScoredProduct[] {
  const answers = payload.answers ?? [];
  const selectedVibes = payload.selectedVibes ?? [];
  const limit = payload.limit ?? DEFAULT_LIMIT;

  const normalizedAnswers = answers
    .map(a => a.toLowerCase())
    .filter(Boolean);

  const selectedVibeSet = new Set(selectedVibes);

  // ðŸ”® AI-derived profile tokens (from Groq)
  const profile = payload.structuredProfile;
  const profileTokens: string[] = [];

  if (profile) {
    profileTokens.push(
      ...(profile.moods ?? []),
      ...(profile.personality ?? []),
      ...(profile.seasons ?? []),
      ...(profile.occasions ?? []),
      ...(profile.genders ?? []),
      ...(profile.notePreferences ?? [])
    );

    if (profile.intensity) profileTokens.push(profile.intensity);
    if (profile.budget) profileTokens.push(profile.budget);
  }

  const normalizedProfileTokens = profileTokens
    .map(t => t.toLowerCase())
    .filter(Boolean);

  const scored: ScoredProduct[] = products.map(product => {
    let score = 0;

    // 1) Base score to avoid all zeroes
    score += 0.1;

    // 2) If product belongs to one of the selected vibes â†’ boost
    const productVibe = vibes.find(v => v.slug === product.vibeSlug) || null;
    const matchedVibes: Vibe[] = [];
    if (productVibe && selectedVibeSet.has(productVibe.slug)) {
      score += 2.5;
      matchedVibes.push(productVibe);
    }

    // Text we search over for both raw keywords and AI tags
    const searchableText = (
      product.description +
      " " +
      product.vibeTags.join(" ")
    ).toLowerCase();

    const matchedKeywords: string[] = [];

    // 3) Keyword matching between raw answers and product text
    for (const answer of normalizedAnswers) {
      const tokens = answer.split(/\s+/).filter(Boolean);
      for (const token of tokens) {
        if (token.length < 3) continue; // skip tiny words like "in", "of"
        if (searchableText.includes(token)) {
          score += 0.4;
          if (!matchedKeywords.includes(token)) {
            matchedKeywords.push(token);
          }
        }
      }
    }

    // 3b) Extra boost for AI-derived structured tags
    for (const token of normalizedProfileTokens) {
      if (token.length < 2) continue;
      if (searchableText.includes(token)) {
        // Slightly higher weight than raw keyword
        score += 0.7;
        if (!matchedKeywords.includes(token)) {
          matchedKeywords.push(token);
        }
      }
    }

    // 4) Tiny bonus if product has many vibe tags
    score += product.vibeTags.length * 0.05;

    return {
      product,
      score,
      matchedVibes,
      matchedKeywords
    };
  });

  // sort descending by score
  scored.sort((a, b) => b.score - a.score);

  // slice to requested limit
  return scored.slice(0, limit);
}
